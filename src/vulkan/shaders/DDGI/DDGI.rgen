//////////////////////////////////////////////////////////////////////////////
// This file is part of the Maple Engine                              		//
//////////////////////////////////////////////////////////////////////////////
#version 460

#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : enable


layout(set = 4, binding = 3, scalar) buffer ProbeState
{
    int8_t probeStates[];
};
#define DDGI_CLASSIFY
#include "DDGICommon.glsl"
#include "../Common/Math.glsl"

layout(location = 0) rayPayloadEXT GIPayload outPayload;

layout(set = 0, binding = 1) uniform accelerationStructureEXT uTopLevelAS;

layout(set = 4, binding = 2, scalar) uniform DDGIUBO
{
    DDGIUniform ddgi;
};

layout(set = 5, binding = 0, rgba16f) uniform image2D iRadiance;
layout(set = 5, binding = 1, rgba16f) uniform image2D iDirectionDistance;

layout(push_constant) uniform PushConstants
{
    mat4  randomOrientation;
    vec4  ambientColor;
    uint  numFrames;
    uint  infiniteBounces;
    float intensity;
}pushConsts;

void main()
{
    const ivec2 texCoords   = ivec2(gl_LaunchIDEXT.xy);
    const int probeId       = texCoords.y;
    const int rayId         = texCoords.x;

    if(DDGI_PROBE_STATE_OUTOF_CAMERA == probeStates[probeId])
        return;

    const bool inactive = probeStates[probeId] == DDGI_PROBE_STATE_INACTIVE;

    uint  rayFlags  = 0;//gl_RayFlagsOpaqueEXT;
    uint  cullMask  = 0xff;
    float tmin      = 0.0001;
    float tmax      = 10000.0;
    vec3  rayOrigin = probeLocation(ddgi, probeId);
    vec3  direction  = normalize(mat3(pushConsts.randomOrientation) * sphericalFibonacci(rayId, inactive ? int(ddgi.raysPerProbe * 0.5) : ddgi.raysPerProbe ));

    outPayload.random = randomInit(texCoords, pushConsts.numFrames);
    outPayload.L = vec3(0.0f);
    outPayload.T = vec3(1.0f);
    outPayload.hitDistance = tmax;

    traceRayEXT(uTopLevelAS, rayFlags, cullMask, 0, 0, 0, rayOrigin, tmin, direction, tmax, 0);

    //get radiance / hitDistance.
    imageStore(iRadiance, texCoords, vec4(outPayload.L, 0.0f));
    imageStore(iDirectionDistance, texCoords, vec4(direction, outPayload.hitDistance));
}
// ------------------------------------------------------------------------